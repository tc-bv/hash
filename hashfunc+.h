#include<bits/stdc++.h>
#include"hash.h"
#pragma once
constexpr int HASHFILE_BUFFER_SIZE=256*1024;
namespace _sha3{
	#include"parts/hash/sha3.h"
} 
namespace _sha256{
	#include"parts/hash/sha256.h"
}
namespace _sha1{
	#include"parts/hash/sha1.h"
}
string hashstr(const string& data,int bits=256){
	return _sha3::SHA3((_sha3::SHA3::Bits)bits)(data);
}
string hashfile(const string& file,int bits=256){
	_sha3::SHA3 sha3((_sha3::SHA3::Bits)bits);
	ifstream fin(file,ios::binary);
	char buffer[HASHFILE_BUFFER_SIZE];
	while(fin.read(buffer,sizeof(buffer))){
		sha3.add(buffer,sizeof(buffer));
	}
	sha3.add(buffer,fin.gcount());
	return sha3.getHash();
}
string hashstr3(const string& data,int bits=256){
	return hashstr(data,bits);
}
string hashfile3(const string& file,int bits=256){
	return hashfile(file,bits);
}
string hashstr256(const string& data){
	return _sha256::SHA256()(data);
}
string hashfile256(const string& file){
	_sha256::SHA256 sha256;
	ifstream fin(file,ios::binary);
	char buffer[HASHFILE_BUFFER_SIZE];
	while(fin.read(buffer,sizeof(buffer))){
		sha256.add(buffer,sizeof(buffer));
	}
	sha256.add(buffer,fin.gcount());
	return sha256.getHash();
}
string hashstr1(const string& data){
	return _sha1::SHA1()(data);
}
string hashfile1(const string& file){
	_sha1::SHA1 sha1;
	ifstream fin(file,ios::binary);
	char buffer[HASHFILE_BUFFER_SIZE];
	while(fin.read(buffer,sizeof(buffer))){
		sha1.add(buffer,sizeof(buffer));
	}
	sha1.add(buffer,fin.gcount());
	return sha1.getHash();
}
//Hex Encode/Decode
string fromhex(const string& hex) {
	static constexpr uint8_t HEX_LUT[256] = {
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
	};
	if (hex.length() % 2 != 0) {
		return "";
	}
	size_t len = hex.length();
	string result;
	result.reserve(len / 2);
	const char* p = hex.data();
	const char* end = p + len;
	while (p < end) {
		uint8_t high = HEX_LUT[(uint8_t)p[0]];
		uint8_t low  = HEX_LUT[(uint8_t)p[1]];
		result.push_back(static_cast<char>((high << 4) | low));
		p += 2;
	}
	return result;
}
string tohex(const string& data, bool uppercase=1) {
	static const char hex_lower[] = "0123456789abcdef";
	static const char hex_upper[] = "0123456789ABCDEF";
	const char* hex_table = uppercase ? hex_upper : hex_lower;
	string result;
	result.reserve(data.length() * 2);
	for (unsigned char c : data) {
		result.push_back(hex_table[c >> 4]);
		result.push_back(hex_table[c & 0x0F]);
	}
	return result;
}
